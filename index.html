<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zufalls-Würfel: Rechnung / Lohnsteuer</title>
<style>
  :root { --size: 180px; } /* 50% größer als zuvor (120px -> 180px) */
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    background:#f6f7fb; color:#111; display:grid; place-items:center; min-height:100svh; margin:0;
  }
  .card {
    background:#fff; padding:16px 16px 20px; border-radius:16px;
    box-shadow:0 8px 24px rgba(0,0,0,.08), 0 2px 6px rgba(0,0,0,.05);
    display:grid; gap:12px; width: min(94vw, 420px); justify-items:center; /* mehr Platz */
  }
  canvas { width: var(--size); height: var(--size); display:block; }
  button {
    appearance:none; border:none; border-radius:999px; padding:10px 18px; font-weight:600;
    background:#111; color:#fff; cursor:pointer; transition:transform .05s ease, opacity .2s ease;
  }
  button:active { transform:translateY(1px) scale(.99); }
  .hint { font-size:12px; color:#666; min-height:1.2em; }
</style>
</head>
<body>
  <div class="card">
    <canvas id="cube" width="180" height="180" aria-label="Würfel: Rechnung oder Lohnsteuer"></canvas>
    <button id="rollBtn" type="button">Würfeln</button>
    <div class="hint" id="resultHint" aria-live="polite"></div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('cube');
  const ctx = canvas.getContext('2d');
  const btn = document.getElementById('rollBtn');
  const hint = document.getElementById('resultHint');

  /* DPI-fit */
  function fitDPR() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const cssW = parseInt(getComputedStyle(canvas).width, 10);
    const cssH = parseInt(getComputedStyle(canvas).height, 10);
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fitDPR();
  addEventListener('resize', fitDPR);

  /* Würfelgeometrie */
  const verts = [
    [-1,-1,-1], [ 1,-1,-1], [ 1, 1,-1], [-1, 1,-1],
    [-1,-1, 1], [ 1,-1, 1], [ 1, 1, 1], [-1, 1, 1],
  ];
  const faces = [
    { idx:[4,5,6,7], name:'+Z' }, // Front
    { idx:[1,0,3,2], name:'-Z' }, // Back
    { idx:[5,1,2,6], name:'+X' }, // Right
    { idx:[0,4,7,3], name:'-X' }, // Left
    { idx:[7,6,2,3], name:'+Y' }, // Top
    { idx:[0,1,5,4], name:'-Y' }, // Bottom
  ];

  /* Zustände */
  let faceLabels = [];
  let yaw = 0, pitch = 0;
  let vy = 0, vp = 0;
  let spinning = false;
  let stopAt = 0;
  let selectedFaceIndex = null; // zum Gelb-Aufleuchten

  /* Zufallshilfen */
  const rand = (a,b) => a + Math.random()*(b-a);
  const shuffled = a => { const r = a.slice(); for(let i=r.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [r[i],r[j]]=[r[j],r[i]]; } return r; };

  function assignLabels() {
    const pool = shuffled(['Rechnung','Rechnung','Rechnung','Lohnsteuer','Lohnsteuer','Lohnsteuer']);
    faceLabels = pool;
  }

  /* Rotation & Projektion (flacher / weniger Perspektive) */
  const PERSPECTIVE = 0.35; // 0 = ortho, 1 = stark perspektivisch
  function rotX(v,a){ const [x,y,z]=v, c=Math.cos(a), s=Math.sin(a); return [x, y*c - z*s, y*s + z*c]; }
  function rotY(v,a){ const [x,y,z]=v, c=Math.cos(a), s=Math.sin(a); return [ x*c + z*s, y, -x*s + z*c ]; }
  function project([x,y,z], fov=6, scale=50) {
    // Mischung aus Ortho & Perspektive für flacheren Look
    const k_p = fov / Math.max(0.0001, (fov - z));
    const k = PERSPECTIVE * k_p + (1 - PERSPECTIVE) * 1; // 1 == ortho
    return [ x*k*scale, y*k*scale ];
  }

  function draw() {
    const w = parseInt(getComputedStyle(canvas).width,10);
    const h = parseInt(getComputedStyle(canvas).height,10);
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(w/2, h/2 + 4); // leicht nach unten

    const rVerts = verts.map(v => rotY(rotX(v, pitch), yaw));

    const order = faces.map((f,i) => {
      const [a,b,c] = f.idx.map(j => rVerts[j]);
      const u = [b[0]-a[0], b[1]-a[1], b[2]-a[2]];
      const v = [c[0]-a[0], c[1]-a[1], c[2]-a[2]];
      const n = [ u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0] ];
      const visible = n[2] > 0;
      const zAvg = f.idx.reduce((acc,j)=>acc + rVerts[j][2],0)/4;
      return { i, visible, zAvg };
    }).sort((A,B)=> A.zAvg - B.zAvg);

    const base = { r: 80, g: 130, b: 255 };
    function shade(zAvg) {
      const t = Math.max(0, Math.min(1, (zAvg + 1.2)/2.4));
      const k = 0.65 + 0.35 * t;
      return `rgb(${Math.round(base.r*k)}, ${Math.round(base.g*k)}, ${Math.round(base.b*k)})`;
    }

    order.forEach(({i, visible, zAvg}) => {
      if (!visible) return;
      const f = faces[i];
      const poly = f.idx.map(j => project(rVerts[j], 6, Math.min(w,h)*0.26)); // kleineres scale -> nicht abgeschnitten
      // Fläche
      ctx.beginPath();
      ctx.moveTo(poly[0][0], poly[0][1]);
      for (let k=1;k<poly.length;k++) ctx.lineTo(poly[k][0], poly[k][1]);
      ctx.closePath();
      ctx.fillStyle = shade(zAvg);
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(0,0,0,.15)";
      ctx.stroke();

      // Gelbes Aufleuchten der ausgewählten Vorderseite (wenn nicht am Drehen)
      if (!spinning && selectedFaceIndex === i) {
        ctx.save();
        ctx.globalAlpha = 0.28;
        ctx.fillStyle = "rgb(255, 235, 59)"; // gelb
        ctx.fill();

        // Glow-Kontur
        ctx.globalAlpha = 1;
        ctx.lineWidth = 3;
        ctx.shadowColor = "rgba(255, 215, 0, 0.95)";
        ctx.shadowBlur = 16;
        ctx.strokeStyle = "rgba(255, 215, 0, 0.95)";
        ctx.stroke();
        ctx.restore();
      }

      // Text mittig
      const label = faceLabels[i] || '';
      if (label) {
        const cx = poly.reduce((s,p)=>s+p[0],0)/poly.length;
        const cy = poly.reduce((s,p)=>s+p[1],0)/poly.length;
        const areaApprox = Math.abs(
          (poly[0][0]*(poly[1][1]-poly[3][1]) + poly[1][0]*(poly[2][1]-poly[0][1]) +
           poly[2][0]*(poly[3][1]-poly[1][1]) + poly[3][0]*(poly[0][1]-poly[2][1]))/2
        );
        const fontSize = Math.max(10, Math.min(16, Math.sqrt(areaApprox)/4));
        ctx.font = `700 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fff";
        ctx.shadowColor = "rgba(0,0,0,.25)";
        ctx.shadowBlur = 2;
        ctx.shadowOffsetY = 1;
        ctx.fillText(label, cx, cy);
        ctx.shadowBlur = 0;
      }
    });

    ctx.restore();
  }

  function currentFrontFace() {
    const rVerts = verts.map(v => rotY(rotX(v, pitch), yaw));
    let best = { index:-1, z:-Infinity };
    faces.forEach((f, i) => {
      const zAvg = f.idx.reduce((acc,j)=>acc + rVerts[j][2],0)/4;
      if (zAvg > best.z) best = { index:i, z:zAvg };
    });
    return best.index;
  }

  /* Animation */
  let raf = null;
  function tick() {
    if (spinning) {
      yaw += vy;
      pitch += vp;
      if (performance.now() >= stopAt) {
        vy *= 0.90;
        vp *= 0.90;
        if (Math.abs(vy) < 0.003 && Math.abs(vp) < 0.003) {
          vy = vp = 0;
          spinning = false;
          selectedFaceIndex = currentFrontFace();
          const outcome = faceLabels[selectedFaceIndex];
          hint.textContent = `Ergebnis: ${outcome}`;
        }
      }
    }
    draw();
    raf = requestAnimationFrame(tick);
  }
  raf = requestAnimationFrame(tick);

  /* Interaktion */
  btn.addEventListener('click', () => {
    assignLabels();
    selectedFaceIndex = null; // Glow zurücksetzen während Drehung
    hint.textContent = "Würfel läuft…";
    vy = rand(0.18, 0.28) * (Math.random() < .5 ? -1 : 1);
    vp = rand(0.12, 0.22) * (Math.random() < .5 ? -1 : 1);
    spinning = true;
    stopAt = performance.now() + 1500; // ~1,5s (bereits verkürzt in der vorherigen Version)
  });

  /* Initiale Darstellung */
  assignLabels();
  yaw = 0.5;        // etwas weniger Kippung
  pitch = -0.20;    // flacher Blickwinkel
  draw();
})();
</script>
</body>
</html>
